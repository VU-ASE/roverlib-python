# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: core/servicediscovery.proto, core/debug.proto, core/tuningstate.proto, core/wrapper.proto, infrastructure/finishLineDetection.proto, outputs/battery.proto, outputs/camera.proto, outputs/controller.proto, outputs/distance.proto, outputs/imu.proto, outputs/laptime.proto, outputs/lux.proto, outputs/rpm.proto, outputs/speed.proto, outputs/wrapper.proto, segmentation/segmentation.proto, simulator/simulator.proto, remoteconfig.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class ServiceStatus(betterproto.Enum):
    UNKNOWN = 0
    REGISTERED = 1
    RUNNING = 2
    STOPPED = 3
    NOT_REGISTERED = 4


class ServiceOptionType(betterproto.Enum):
    STRING = 0
    INT = 1
    FLOAT = 2


class ServiceOrderOrderType(betterproto.Enum):
    STOP = 0
    KILL = 1
    FORCE_RESTART = 2


class DetectedObjects(betterproto.Enum):
    """Possible Objects the Imaging Module may detect"""

    FINISH_LINE = 0
    OFF_TRACK = 1
    OBSTACLE = 2
    INTERSECTION = 3
    MISSING_LEFT_LANE = 4
    MISSING_RIGHT_LANE = 5
    SHARP_RIGHT = 6
    SHARP_LEFT = 7
    U_TURN = 8
    S_TURN = 9


class SimStatus(betterproto.Enum):
    """Possible Sim Requests. Useful for interfaces with Gym"""

    SIM_PAUSED = 0
    SIM_REQ_STEP = 1
    SIM_REQ_RESET = 2


class ConfigMessageControlRequestType(betterproto.Enum):
    HUMAN_CONTROL_TAKEOVER = 0
    HUMAN_CONTROL_RELEASE = 1


@dataclass
class ServiceIdentifier(betterproto.Message):
    """Used to identify a service within the system"""

    name: str = betterproto.string_field(1)
    pid: int = betterproto.int32_field(2)


@dataclass
class ServiceEndpoint(betterproto.Message):
    """An endpoint that is made available by a service"""

    name: str = betterproto.string_field(1)
    address: str = betterproto.string_field(2)


@dataclass
class ServiceOption(betterproto.Message):
    """The options that can be set for a service"""

    name: str = betterproto.string_field(1)
    type: "ServiceOptionType" = betterproto.enum_field(2)
    mutable: bool = betterproto.bool_field(3)
    # should be set and checked based on the type
    string_default: str = betterproto.string_field(4)
    int_default: int = betterproto.int32_field(5)
    float_default: float = betterproto.float_field(6)


@dataclass
class ServiceDependency(betterproto.Message):
    """
    The core knows the dependencies of each service, to build a dependency
    graph
    """

    service_name: str = betterproto.string_field(1)
    output_name: str = betterproto.string_field(2)


@dataclass
class Service(betterproto.Message):
    """
    A description of a service, sent by a service to register itself or
    broadcasted by the core
    """

    identifier: "ServiceIdentifier" = betterproto.message_field(1)
    endpoints: List["ServiceEndpoint"] = betterproto.message_field(2)
    options: List["ServiceOption"] = betterproto.message_field(3)
    dependencies: List["ServiceDependency"] = betterproto.message_field(4)
    status: "ServiceStatus" = betterproto.enum_field(5)
    registered_at: int = betterproto.int64_field(6)


@dataclass
class ServiceInformationRequest(betterproto.Message):
    """
    When a service requests information about other services, it sends an
    InformationRequest message
    """

    requested: "ServiceIdentifier" = betterproto.message_field(1)


@dataclass
class ServiceOrder(betterproto.Message):
    """
    The core can order services to stop/restart by sending a service order
    """

    # The service this order is for
    service: "ServiceIdentifier" = betterproto.message_field(1)
    order: "ServiceOrderOrderType" = betterproto.enum_field(2)


@dataclass
class ServiceListRequest(betterproto.Message):
    """
    When a service wants to fetch all services, it sends a ServiceListRequest
    """

    requested: "ServiceIdentifier" = betterproto.message_field(1)


@dataclass
class ServiceList(betterproto.Message):
    """When the core sends a list of services, it sends a ServiceList"""

    services: List["Service"] = betterproto.message_field(1)


@dataclass
class ServiceStatusUpdate(betterproto.Message):
    """This will inform the core of a status update"""

    service: "ServiceIdentifier" = betterproto.message_field(1)
    status: "ServiceStatus" = betterproto.enum_field(2)


@dataclass
class DebugServiceMessage(betterproto.Message):
    """
    When the debug transceiver picks up a SensorOutput message, it will wrap it
    in a DebugSensorOutput message, so that the receiver can determine from
    which process the message originated
    """

    service: "ServiceIdentifier" = betterproto.message_field(1)
    endpoint: "ServiceEndpoint" = betterproto.message_field(2)
    sent_at: int = betterproto.int64_field(4)
    message: bytes = betterproto.bytes_field(3)


@dataclass
class TuningState(betterproto.Message):
    timestamp: int = betterproto.uint64_field(1)
    dynamic_parameters: List["TuningStateParameter"] = betterproto.message_field(2)


@dataclass
class TuningStateParameter(betterproto.Message):
    float: "TuningStateParameterFloatParameter" = betterproto.message_field(
        1, group="parameter"
    )
    int: "TuningStateParameterIntParameter" = betterproto.message_field(
        2, group="parameter"
    )
    string: "TuningStateParameterStringParameter" = betterproto.message_field(
        3, group="parameter"
    )


@dataclass
class TuningStateParameterFloatParameter(betterproto.Message):
    """
    note: it may seem weird to not extract the key from the oneof, but this is
    so that the parser can easily determine the type of the parameter
    extracting it to a separate field on the same level as oneof would make it
    ambiguous
    """

    key: str = betterproto.string_field(1)
    value: float = betterproto.float_field(2)


@dataclass
class TuningStateParameterIntParameter(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: int = betterproto.int64_field(2)


@dataclass
class TuningStateParameterStringParameter(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class TuningStateRequest(betterproto.Message):
    timestamp: int = betterproto.uint64_field(1)


@dataclass
class Error(betterproto.Message):
    message: str = betterproto.string_field(1)


@dataclass
class CoreMessage(betterproto.Message):
    service: "Service" = betterproto.message_field(1, group="msg")
    service_order: "ServiceOrder" = betterproto.message_field(4, group="msg")
    tuning_state: "TuningState" = betterproto.message_field(5, group="msg")
    tuning_state_request: "TuningStateRequest" = betterproto.message_field(
        6, group="msg"
    )
    service_list_request: "ServiceListRequest" = betterproto.message_field(
        7, group="msg"
    )
    service_list: "ServiceList" = betterproto.message_field(8, group="msg")
    service_status_update: "ServiceStatusUpdate" = betterproto.message_field(
        9, group="msg"
    )
    service_information_request: "ServiceInformationRequest" = (
        betterproto.message_field(10, group="msg")
    )
    error: "Error" = betterproto.message_field(11, group="msg")


@dataclass
class FinsihLineDetectionOutput(betterproto.Message):
    timestamp: int = betterproto.uint64_field(1)


@dataclass
class BatterySensorOutput(betterproto.Message):
    current_output_voltage: float = betterproto.float_field(1)
    warn_voltage: float = betterproto.float_field(2)
    kill_voltage: float = betterproto.float_field(3)


@dataclass
class CanvasObject(betterproto.Message):
    line: "CanvasObjectLine" = betterproto.message_field(1, group="object")
    rectangle: "CanvasObjectRectangle" = betterproto.message_field(2, group="object")
    circle: "CanvasObjectCircle" = betterproto.message_field(3, group="object")


@dataclass
class CanvasObjectPoint(betterproto.Message):
    x: int = betterproto.uint32_field(1)
    y: int = betterproto.uint32_field(2)


@dataclass
class CanvasObjectColor(betterproto.Message):
    r: int = betterproto.uint32_field(1)
    g: int = betterproto.uint32_field(2)
    b: int = betterproto.uint32_field(3)
    a: int = betterproto.uint32_field(4)


@dataclass
class CanvasObjectLine(betterproto.Message):
    start: "CanvasObjectPoint" = betterproto.message_field(1)
    end: "CanvasObjectPoint" = betterproto.message_field(2)
    width: int = betterproto.uint32_field(3)
    color: "CanvasObjectColor" = betterproto.message_field(4)


@dataclass
class CanvasObjectRectangle(betterproto.Message):
    top_left: "CanvasObjectPoint" = betterproto.message_field(1)
    bottom_right: "CanvasObjectPoint" = betterproto.message_field(2)
    width: int = betterproto.uint32_field(3)
    color: "CanvasObjectColor" = betterproto.message_field(4)


@dataclass
class CanvasObjectCircle(betterproto.Message):
    center: "CanvasObjectPoint" = betterproto.message_field(1)
    radius: int = betterproto.uint32_field(2)
    width: int = betterproto.uint32_field(3)
    color: "CanvasObjectColor" = betterproto.message_field(4)


@dataclass
class Canvas(betterproto.Message):
    width: int = betterproto.uint32_field(1)
    height: int = betterproto.uint32_field(2)
    objects: List["CanvasObject"] = betterproto.message_field(3)


@dataclass
class CameraSensorOutput(betterproto.Message):
    """
    The following sensor outputs are specific to the sensor type, bring your
    own sensor and add your own output here!
    """

    trajectory: "CameraSensorOutputTrajectory" = betterproto.message_field(1)
    debug_frame: "CameraSensorOutputDebugFrame" = betterproto.message_field(2)
    objects: "CameraSensorOutputObjects" = betterproto.message_field(3)


@dataclass
class CameraSensorOutputTrajectory(betterproto.Message):
    """Defined by the Path Planner"""

    points: List["CameraSensorOutputTrajectoryPoint"] = betterproto.message_field(1)
    width: int = betterproto.uint32_field(2)
    height: int = betterproto.uint32_field(3)


@dataclass
class CameraSensorOutputTrajectoryPoint(betterproto.Message):
    x: int = betterproto.int32_field(1)
    y: int = betterproto.int32_field(2)


@dataclass
class CameraSensorOutputDebugFrame(betterproto.Message):
    jpeg: bytes = betterproto.bytes_field(1)
    # if image livestreaming is disabled, or imaging module wants to draw
    # additional information on the image, it can be done here
    canvas: "Canvas" = betterproto.message_field(5)


@dataclass
class CameraSensorOutputObjects(betterproto.Message):
    items: List["DetectedObjects"] = betterproto.enum_field(1)


@dataclass
class ControllerOutput(betterproto.Message):
    # Steering angle (-1.0 to 1.0 <-> left - right)
    steering_angle: float = betterproto.float_field(2)
    # Throttle (-1.0 to 1.0 <-> full reverse - full forward)
    left_throttle: float = betterproto.float_field(3)
    right_throttle: float = betterproto.float_field(4)
    # Onboard lights (0.0 to 1.0 <-> off - on)
    front_lights: bool = betterproto.bool_field(5)
    # Fan speed (0.0 to 1.0 <-> off - full speed)
    fan_speed: float = betterproto.float_field(6)
    # Useful for debugging
    raw_error: float = betterproto.float_field(7)
    scaled_error: float = betterproto.float_field(8)


@dataclass
class DistanceSensorOutput(betterproto.Message):
    # distance in meters
    distance: float = betterproto.float_field(1)


@dataclass
class ImuSensorOutput(betterproto.Message):
    temperature: int = betterproto.int32_field(1)
    magnetometer: "ImuSensorOutputVector" = betterproto.message_field(2)
    gyroscope: "ImuSensorOutputVector" = betterproto.message_field(3)
    euler: "ImuSensorOutputVector" = betterproto.message_field(4)
    accelerometer: "ImuSensorOutputVector" = betterproto.message_field(5)
    linear_accelerometer: "ImuSensorOutputVector" = betterproto.message_field(6)
    velocity: "ImuSensorOutputVector" = betterproto.message_field(7)
    speed: float = betterproto.float_field(8)


@dataclass
class ImuSensorOutputVector(betterproto.Message):
    x: float = betterproto.float_field(1)
    y: float = betterproto.float_field(2)
    z: float = betterproto.float_field(3)


@dataclass
class LapTimeOutput(betterproto.Message):
    lap_time: int = betterproto.uint64_field(1)
    lap_start_time: int = betterproto.uint64_field(2)


@dataclass
class LuxSensorOutput(betterproto.Message):
    lux: int = betterproto.int32_field(1)


@dataclass
class RpmSensorOutput(betterproto.Message):
    left_rpm: float = betterproto.float_field(1)
    left_angle: float = betterproto.float_field(2)
    right_rpm: float = betterproto.float_field(3)
    right_angle: float = betterproto.float_field(4)


@dataclass
class SpeedSensorOutput(betterproto.Message):
    rpm: int = betterproto.int32_field(1)


@dataclass
class SensorOutput(betterproto.Message):
    # Every sensor has a unique ID to support multiple sensors of the same type
    sensor_id: int = betterproto.uint32_field(1)
    # Add a timestamp to the output to make debugging, logging and
    # synchronisation easier
    timestamp: int = betterproto.uint64_field(2)
    # Report an error if the sensor is not working correctly (controller can
    # decide to ignore or stop the car) 0 = no error, any other value = error
    status: int = betterproto.uint32_field(3)
    camera_output: "CameraSensorOutput" = betterproto.message_field(
        4, group="sensorOutput"
    )
    distance_output: "DistanceSensorOutput" = betterproto.message_field(
        5, group="sensorOutput"
    )
    speed_output: "SpeedSensorOutput" = betterproto.message_field(
        6, group="sensorOutput"
    )
    controller_output: "ControllerOutput" = betterproto.message_field(
        7, group="sensorOutput"
    )
    imu_output: "ImuSensorOutput" = betterproto.message_field(8, group="sensorOutput")
    battery_output: "BatterySensorOutput" = betterproto.message_field(
        9, group="sensorOutput"
    )
    rpm_ouput: "RpmSensorOutput" = betterproto.message_field(10, group="sensorOutput")
    lux_output: "LuxSensorOutput" = betterproto.message_field(11, group="sensorOutput")
    laptime_output: "LapTimeOutput" = betterproto.message_field(
        12, group="sensorOutput"
    )


@dataclass
class Segment(betterproto.Message):
    """control messages exchanged by client(s), the server and the car"""

    packet_id: int = betterproto.int64_field(1)
    segment_id: int = betterproto.int64_field(2)
    total_segments: int = betterproto.int64_field(3)
    data: bytes = betterproto.bytes_field(4)


@dataclass
class SimulatorImageOutput(betterproto.Message):
    """Simulator sensor outputs."""

    width: int = betterproto.uint32_field(2)
    height: int = betterproto.uint32_field(3)
    pixels: bytes = betterproto.bytes_field(4)


@dataclass
class SimulatorState(betterproto.Message):
    """Generic state of Simulator"""

    speed: float = betterproto.float_field(1)
    wheel_off_track: List[bool] = betterproto.bool_field(2)
    image: "SimulatorImageOutput" = betterproto.message_field(3)
    pos: List[float] = betterproto.float_field(4)
    is_drifting: bool = betterproto.bool_field(5)


@dataclass
class ConfigMessage(betterproto.Message):
    """control messages exchanged by client(s), the server and the car"""

    human_control_request: "ConfigMessageHumanControlRequest" = (
        betterproto.message_field(1, group="action")
    )
    human_control_state: "ConfigMessageHumanControlState" = betterproto.message_field(
        3, group="action"
    )
    car_state: "ConfigMessageCarState" = betterproto.message_field(6, group="action")
    error: "ConfigMessageError" = betterproto.message_field(7, group="action")
    timestamp: int = betterproto.int64_field(2)


@dataclass
class ConfigMessageHumanControlRequest(betterproto.Message):
    type: "ConfigMessageControlRequestType" = betterproto.enum_field(1)


@dataclass
class ConfigMessageHumanControlState(betterproto.Message):
    # let everyone know who is the active controller now
    active_controller_id: str = betterproto.string_field(1)


@dataclass
class ConfigMessageCarState(betterproto.Message):
    """Broadcast car connects and disconnects"""

    connected: bool = betterproto.bool_field(1)
    # We use these fields to calculate the offset between the car and the server
    # time this is used to correctly chart the car's data, even if the car and
    # the server have different clocks note: this does assume that the
    # webcontroller and the forwarding server have synced clocks
    timestamp_offset: int = betterproto.int64_field(2)


@dataclass
class ConfigMessageError(betterproto.Message):
    """To report unknown or general errors"""

    message: str = betterproto.string_field(1)
